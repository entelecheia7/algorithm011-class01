# 位运算
- 左移（<<）
- 右移（>>）
- 或（|）：二进制位均为0则为0，其他情况为1
- 与（&）：二进制位均为1则为1，其他情况是0
- 取反（~）：二进制位反转，1变0，0变1
- 异或（^）：二进制位相同是0，不同是1

异或操作的特点：
```
x ^ 0 = x
x ^ (~0) = ~x
x ^ (~x) = ~0
x ^ x = 0
c = a ^ b  =>  a ^ c = b, b ^ c = a
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c
```
常用的位运算：
- 将x右n位清零：x & (~0 << n)
- 获取x第n位的值：(x >> n) & 1
- 获取x第n位的幂值：x & (1<<n)
- 将第n位置为1：x | (1<<n)
- 将第n位置为0：x & (~(1<<n))
- 将x最高位至第n位（含）清零：x & ((1<<n)-1)
- 判断奇偶：
    - (x & 1) == 1
    - (x & 1) == 0
- 清零最低位的1：x & (x-1)
- 得到最低位的1：x & -x
- 判等：x & (~x) == 0


# 布隆过滤器
布隆过滤器由一个很长的二进制向量和一系列随机映射函数组成。它用于检测一个元素是否在一个集合中。它的优点在于空间消耗少、查询时间少，但有一定的误识别率、删除困难。  
布隆过滤器的应用场景有：数据库缓存层、垃圾邮件过滤、推荐去重、分布式系统判断数据是否存在于当前节点。

# 排序算法
排序大致分为两类，比较类排序和非比较类排序。  
比较类排序通过比较决定元素间的相对次序，时间复杂度最好是 O(logn)，也称为非线性时间比较类排序。  
非比较类排序不通过比较来决定元素间的相对次序，时间复杂度是线性的，因此也称为线性时间比较类排序。  
比较类排序包括：
- 交换排序
    - 冒泡排序
    - 快速排序
- 插入排序
    - 插入排序
    - 希尔排序
- 选择排序
    - 选择排序
    - 堆排序
- 归并排序
    - 二路归并排序
    - 多路归并排序

非比较类排序包括：
- 计数排序
- 桶排序
- 基数排序

## 选择排序
每次找最小值，放到待排序数组的起始位置。
```
func selectionSort(nums []int, n int) {
	pos := 0 // 待排序数组起始位置
	for pos < n {
		minest := pos
		for i := pos + 1; i < n; i++ {
			if nums[i] < nums[minest] {
				minest = i
			}
		}
		nums[pos], nums[minest] = nums[minest], nums[pos]
		pos++
	}
}
```

## 插入排序
对于未排序数据，在已排序序列中从后往前扫描，找到相应位置插入。
```
func insertionSort(nums []int, n int) {
	pos := 1 // 未排序数据的起始位置
	for pos < n {
		i := pos - 1
		cur := nums[pos] // 本次循环的待插入数据
		for i >= 0 && nums[i] > cur {
			nums[i+1] = nums[i]
			i--
		}
		nums[i+1] = cur
		pos++
	}
}
```

## 冒泡排序
多层循环，每次检查相邻元素的顺序，逆序则交换。
```
func BubbleSort(nums []int, n int) {
    for j := 0; j < n-1; j++ {
        flag := true
        for i := 0; i < n-1; i++ {
            if nums[i] > nums[i+1] {
                falg := false
                nums[i], nums[i+1] = nums[i+1], nums[i]
            }
        }
        if flag {
            break
        }
    }
}

```


4. 归并排序
5. 快速排序
6. 桶排序
7. 计数排序
8. 基数排序